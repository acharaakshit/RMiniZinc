#include <Rcpp.h>
#include <regex>
#include "helper_parse.h"


using namespace Rcpp;
using namespace MiniZinc;
using namespace std;

//' @title parse the solution
//' 
//' @description can parse the solution of a model
//' 
//' @importFrom Rcpp sourceCpp
//' @export sol_parse
//' @useDynLib rminizinc, .registration=TRUE
//' @param solutionString solution of the model as a string representation
// [[Rcpp::export]]
List sol_parse(std::string solutionString) {
  
  string delimiter = "----------";
  size_t pos = 0;
  static const size_t npos = -1;
  std::string token;
  vector<string> solutions;
  
  while ((pos = solutionString.find(delimiter)) != npos) {
    token = solutionString.substr(0, pos);
    solutions.push_back(token);
    solutionString.erase(0, pos + delimiter.length());
  }
  
  if(solutionString.find("=====UNSATISFIABLE=====") != npos){
    Rcpp::stop("No Solution");
  }
  
  if(solutions.size()==0) Rcpp::stop("No solution seperator found-- incorrect solution string");
  
  int optimal_sol_flag = solutionString.find("==========") != npos ? 1:0;
  
  
  List retVal;
  CharacterVector nameretVal;
  
  for(int nsol=0; nsol< solutions.size(); nsol++){
    
    List thisSol;
    solutionString = solutions[nsol];
    CharacterVector varName;

    Model *model = helper_parse(solutionString, "solution.mzn");

    int s = (model-> size());
    if(s==0) Rcpp::stop("empty model generated by solution string");
    
    vector<Item*> items;
    for(int i=0; i < s; i++){
      items.push_back(model->operator[] (i));
      bool isAssignment = (int)items[i]->iid()==Item::II_ASN?true:false;
      if(isAssignment){
        varName.push_back(items[i]->cast<AssignI>()->id().str());
        int type = items[i]->cast<AssignI>()->e()->eid();
        if(type==Expression::E_INTLIT){
          thisSol.push_back(items[i]->cast<AssignI>()->e()->cast<IntLit>()->v().toInt());
        }else if(type==Expression::E_FLOATLIT){
          thisSol.push_back(items[i]->cast<AssignI>()->e()->cast<FloatLit>()->v().toDouble()); 
        }else if(type==Expression::E_BOOLLIT){
          thisSol.push_back(items[i]->cast<AssignI>()->e()->cast<BoolLit>()->v()); 
        }else if(type==Expression::E_SETLIT){
          SetLit *sl = items[i]->cast<AssignI>()->e()->cast<SetLit>();
          if(sl->isv()!= NULL){  
            int max_val = sl->isv()->max().toInt();
            int min_val = sl->isv()->min().toInt();  
            IntegerVector setVec = {max_val, min_val}; 
            thisSol.push_back(setVec);
          }else if(sl->fsv()!=NULL){
            float max_val =  sl->fsv()->max().toDouble();
            float min_val =  sl->fsv()->min().toDouble();
            NumericVector setVec = {max_val, min_val};
            thisSol.push_back(setVec);
          }else{
            ASTExprVec<Expression> expVec = sl->v();
            int expVec_size = expVec.size();
            List setVec;
            for(int p = 0; p < expVec_size; p++){
              Expression *exp = expVec.operator[](p);
              if(exp->isUnboxedInt()){
                setVec.push_back((double)exp->unboxedIntToIntVal().toInt());
              }else if(exp->isUnboxedFloatVal()){
                setVec.push_back(exp->unboxedFloatToFloatVal().toDouble());
              }else if(exp->eid() == Expression::E_BOOLLIT){
                setVec.push_back(exp->cast<BoolLit>()->v());
              }
            }
            thisSol.push_back(setVec);
          } 
        }else if(type == Expression::E_ARRAYLIT){
          ArrayLit *al = items[i]->cast<AssignI>()->e()->cast<ArrayLit>();
          if(al->getVec().size()){
            int vec_size = al->getVec().size();
            List ArrVec;
            for(int p = 0;p < vec_size; p++ ){
              // get the expression form of each element
              Expression *exp = al->getVec().operator[](p);
              if(exp->isUnboxedInt()){
                ArrVec.push_back((double)exp->unboxedIntToIntVal().toInt());
              }else if(exp->isUnboxedFloatVal()){
                ArrVec.push_back(exp->unboxedFloatToFloatVal().toDouble());
              }else if(exp->eid() == Expression::E_BOOLLIT){
                ArrVec.push_back(exp->cast<BoolLit>()->v());
              }
            }
            thisSol.push_back(ArrVec);
          }   
        }else if(type == Expression::E_CALL){
          Call *cl = items[i]->cast<AssignI>()->e()->cast<Call>();
          // name of the function
          string fnName = cl->id().c_str();
          NumericVector dimVec;
          for(int m = 0;m<cl->n_args();m++){
            int fntype = cl->arg(m)->eid();
            // apply switch case again 
            if(fntype==Expression::E_ARRAYLIT){
              //number of elements in the array
              int vec_size = cl->arg(m)->cast<ArrayLit>()->getVec().size();
              List ArrVec; 
              for(int p = 0;p < vec_size; p++ ){
                // get the expression form of each element
                Expression *exp = cl->arg(m)->cast<ArrayLit>()->getVec().operator[](p);
                if(exp->isUnboxedInt()){
                  ArrVec.push_back((double)exp->unboxedIntToIntVal().toInt());
                }else if(exp->isUnboxedFloatVal()){
                  ArrVec.push_back(exp->unboxedFloatToFloatVal().toDouble());
                }else if(exp->eid() == Expression::E_SETLIT){
                  SetLit *sl = exp->cast<SetLit>();
                  if(sl->isv()!= NULL){  
                    int max_val = sl->isv()->max().toInt();
                    int min_val = sl->isv()->min().toInt();  
                    IntegerVector setVec = {max_val, min_val}; 
                    ArrVec.push_back(setVec);
                  }else if(sl->fsv()!=NULL){
                    float max_val =  sl->fsv()->max().toDouble();
                    float min_val =  sl->fsv()->min().toDouble();
                    NumericVector setVec = {max_val, min_val};
                    ArrVec.push_back(setVec);
                  }else{
                    ASTExprVec<Expression> expVec = sl->v();
                    int expVec_size = expVec.size();
                    List setVec;
                    for(int p = 0; p < expVec_size; p++){
                      Expression *exp = expVec.operator[](p);
                      if(exp->isUnboxedInt()){
                        setVec.push_back((double)exp->unboxedIntToIntVal().toInt());
                      }else if(exp->isUnboxedFloatVal()){
                        setVec.push_back(exp->unboxedFloatToFloatVal().toDouble());
                      }else if(exp->eid() == Expression::E_BOOLLIT){
                        setVec.push_back(exp->cast<BoolLit>()->v());
                      }
                    }
                    ArrVec.push_back(setVec);
                  } 
                }else if(exp->eid() == Expression::E_BOOLLIT){
                    ArrVec.push_back(exp->cast<BoolLit>()->v());
                }else{
                  Rcpp::stop("Array elements can't be parsed");
                }
              }
              if(dimVec.length()==2){
                if(dimVec[0]*dimVec[1] != vec_size){
                  Rcpp:stop("Incorrect dimensions for array2d");
                } 
                ArrVec.attr("dim") = Dimension(dimVec[0], dimVec[1]);
              }else if(dimVec.length()>2){
                Rcpp::stop("More than 2d arrays not supported yet!");
              }
              thisSol.push_back(ArrVec);
            }else if(fntype == Expression::E_SETLIT){
              SetLit *sl = cl->arg(m)->cast<SetLit>();
              if(sl->isv()!= NULL){  
                int max_val =  sl->isv()->max().toInt();
                int min_val = sl->isv()->min().toInt();  
                // dimensions will be stored as 0 to max_val-min_val+1
                dimVec.push_back(max_val-min_val+1);
              }else{
                Rcpp::stop("Not working -- not integer set range"); 
              }
            }else{
              Rcpp::stop("function call not supported");
            }
          }
        }else
          Rcpp::stop("This assignment is not supported yet");
      }else {
        Rcpp::stop("Solution string contains non assignments");
      }
      thisSol.names() = varName;
    }
    string track_nsol = "solution:";
    track_nsol.append(to_string(nsol));
    if(nsol == solutions.size()-1 && optimal_sol_flag){
      track_nsol = "optimal_solution";
    }else if(nsol == solutions.size()-1){
      track_nsol = "best_solution";
    }
    retVal.push_back(thisSol);
    nameretVal.push_back(track_nsol);
  }
  retVal.names() = nameretVal;
  
  return retVal;
}