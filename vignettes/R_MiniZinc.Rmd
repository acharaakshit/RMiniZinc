---
title: "MiniZinc Interface for R"
author: Akshit Achara 
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{R functionalities to use MiniZinc}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---


## Introduction

MiniZinc is a free and open-source constraint modeling language. Constraint satisfaction and discrete optimization problems can be formulated in a high-level modeling language. Models are compiled into an intermediate representation that is understood by a wide range of solvers. MiniZinc itself provides several solvers, for instance GeoCode. The existing packages in R are not powerful enough to solve even mid-sized problems in combinatorial optimization

There are implementations of an Interface to MiniZinc in Python like MiniZinc Python and pymzn and JMiniZinc for Java but such an interface does not exist for R.

This package provides an implementation of a very simple and easy to use interface for R that will help R users to solve optimization problems that can't be solved with R currently.

It's important to understand R6 classes before getting into the details. If you are not comfortable with R6, please go through this [tutorial](https://adv-r.hadley.nz/r6.html).

It would be nice to go through this [manual](https://www.minizinc.org/tutorial/minizinc-tute.pdf) to understand more about MiniZinc. This is mainly for those who are interested in contributing to the package.

Please make sure to install MiniZinc on your operating system and also ensure that minizinc is accessible from command line by typing 'minizinc' on the command line without the single quotes. The installation instructions can be found at [instructions](https://www.minizinc.org/doc-2.4.3/en/installation.html)


## Variables

There are two types of variables in MiniZinc -- decision variables and parameters. 

The data types of variables can be single types i.e integers (int), floating point numbers (float), Booleans (bool) and strings (string) but strings are only used in output formatting so they won't be used as data types and collections i.e sets, enums and arrays (upto 5 dimensional arrays).

Parameter is used to specify a parameter in a given problem and they are assigned a fixed value.

Decision variables are the unknowns that Minizinc model is finding solutions for. We do not need to give them a value, but instead we give them a domain of possible values. Sometimes expressions involving other variables and paramters are also assigned to decision variables. Decision variables need to satisfy a set of constraints which form the core of the problem. 

Here are examples of how we can create parameters and decision variables.

```{r}
library(rminizinc)
# declare an array parameter (only dimensions upto 5 are allowed)
par = variable$new(type = "array", kind = "parameter", sub_type = "int", value = array(1:50, c(10,10,10,10,10)))
# declare a floating point decision variable with a domain of (0,1)
dec = variable$new(type = "float", kind = "decision", domain = c(0, 1))
```

More information on variable is available in `?variable`. Currently only integer, float or boolean arrays are supported and only integer indices can be used.

## Constraints

Constraints specify the Boolean expressions that decision variables must satisfy. Examples of such constraints are given below. 

```{r}
par = variable$new(type = "float", kind = "parameter", value = 3)
# decision variables can be declared without a domain also
var1 = variable$new(type = "float", kind = "decision")
var2 = variable$new(type = "float", kind = "decision", domain = c(0, par$value))
# get the LHS expression of the constraint
LHS_expr = get_expression$new(variables = c(var1,var2), arithmetic_operator = "+" )
# get the right hand side expression of the constraint
RHS_expr = get_expression$new(variables = c(var1,var2), arithmetic_operator = "*" )
constr = constraint$new(operator = ">=", LHS_expression = LHS_expr, RHS_expression = RHS_expr)
```

For now, this package can only support constraints which involve arithmetic operators only. The utility to use inbuilt functions and loops like 'forall' and 'exists' will be provided soon.

## Objective

The constraint programming problem can be of three types, namely: Satisfaction , Minimization and Maximization.
Satisfaction problems produce all the solutions that satify the constraints whereas minimization and maximization problems produce the solution which minimizes and maximizes the given arithmetic expression.
An example of how to specify the objective is shown below:

```{r}
obj <- objective$new(type_of_problem = "satisfy")
```


## Models

The components mentioned above can be combined to create a MiniZinc model. The demonstration of the same is given below:

Here is a model for determining how many banana and chocolate cakes to bake for the
school fete.

```{r}
# decision variables

# number of bananas
v1 = variable$new(type = "int", kind = "decision", domain = c(0, 100), 
                  name = "b")
# number pf cakes
v2 = variable$new(type = "int", kind = "decision", domain = c(0, 100), 
                  name = "c")


vars = c(v1, v2)

# constraints
c1 = constraint$new(operator = "<=", LHS_expr = get_expression$new(variables = c(250,v1,200,v2),
                                                          arithmetic_operator = c("*","+","*")), 
                                                RHS_expr = get_expression$new(variables = 4000))
c2 = constraint$new(operator = "<=", LHS_expr = get_expression$new(variables = c(2, v1),
                                                          arithmetic_operator = "*"), 
                                                RHS_expr = get_expression$new(variables = 6))
c3 = constraint$new(operator = "<=", LHS_expr = get_expression$new(variables = c(75,v1,150,v2),
                                                          arithmetic_operator = c("*","+","*")), 
                                     RHS_expr = get_expression$new(variables = 2000))
c4 = constraint$new(operator = "<=", LHS_expr = get_expression$new(variables = c(100,v1,150,v2),
                                                          arithmetic_operator = c("*","+","*")), 
                                     RHS_expr = get_expression$new(variables = 500))
c5 = constraint$new(operator = "<=", LHS_expr = get_expression$new(variables = c(75, v2),
                                                          arithmetic_operator = "*"), 
                                                RHS_expr = get_expression$new(variables = 500))


constr = c(c1, c2, c3, c4, c5)

objective_of_problem  = objective$new(type_of_problem = "maximize", 
                                      arithmetic_expression = get_expression$new(variables = c(400,v1,450,v2),
                                                                        arithmetic_operator = c("*","+","*")))

# create the model
m = model$new(decision = vars, constraints = constr, 
              objective = objective_of_problem)
```

Now, we have created the model and have set up MiniZinc on our system. The next step is to evaluate the results.
The information about result class and how to use it correctly can be found using `?results`. We wish to get all the solutions of the problem so we will set `all_solutions` to `TRUE`

```{r}
solution <- results$new(model = m, result_type = "R6", all_solutions = TRUE)
# show the solution
print(solution$result$optimal_solution)
```
The results can be obtained as strings or R6 objects. The R6 object has three attributes namely: `solutions`, `best_solution` and `optimal_solution` which contain all the solutions, the best solution found and the optimal solution respectively


```{r,echo=FALSE}
# remove the temporary model file 
file.remove(solution$mzn)
```

A Minizinc implementation of the same problem is given below:

```{minizinc}

% Baking cakes for the school fete
var 0..100: b; % no. of banana cakes
var 0..100: c; % no. of chocolate cakes
% flour
constraint 250*b + 200*c <= 4000;
% bananas
constraint 2*b <= 6;
% sugar
constraint 75*b + 150*c <= 2000;
% butter
constraint 100*b + 150*c <= 500;
% cocoa
constraint 75*c <= 500;
% maximize our profit
solve maximize 400*b + 450*c;

```


Now, that the basic structure of the problem is clear, we can create functions for solving different constraint programming problems.

The workflow of the approach used above is given below:
```{r Workflow 1, echo=FALSE, out.width = '100%'}
knitr::include_graphics(paste0(getwd(),"/workflows/first_approach.png"))
```

This approach is helpful for R users who have little understanding of MiniZinc.

The next approach is to use the MiniZinc C++ API. This involves giving the MiniZinc model to the Rcpp function, evaluate the results and return them back to R. The workflow can be seen below:
```{r Workflow 2, echo=FALSE, out.width = '100%'}
knitr::include_graphics(paste0(getwd(),"/workflows/ongoing_approach.png"))
```
This has not been developed at present.

A parser function `parse_MiniZinc` has also been implemented which can be used to detect possible syntax errors before the MiniZinc model is evaluated. 

```{r}
rminizinc:::mzn_parse("var 0..100: b; var 0..100: c; constraint 250*b + 200*c <= 4000; constraint 2*b <= 6; constraint 75*b + 150*c <= 2000; constraint 100*b + 150*c <= 500; constraint 75*c <= 500; solve maximize 400*b + 450*c;")
```

The function `mzn_eval` can be used to evaluate a MiniZinc model. A string model should be passed to the function along with the solver name along with the path of the MiniZinc library where the solver to be used is present. This is still under development.

```{r}
modelString="int: n=3; set of int: OBJ = 1..n; int: capacity=9; array[OBJ] of int: profit=[15,10,7]; array[OBJ] of int: size=[4,3,2]; array[OBJ] of var int: x; constraint forall(i in OBJ)(x[i] >= 0); constraint sum(i in OBJ)(size[i] * x[i]) <= capacity; solve maximize sum(i in OBJ)(profit[i] * x[i]);"
rminizinc:::mzn_eval(modelString = modelString, solver = "org.gecode.gecode",
                     libpath = "/snap/minizinc/current/share/minizinc")
```
