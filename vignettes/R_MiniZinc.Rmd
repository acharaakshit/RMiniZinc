---
title: "MiniZinc Interface with R"
author: Akshit Achara 
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{R functionalities to use MiniZinc}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---


## Introduction

MiniZinc is a free and open-source constraint modeling language. Constraint satisfaction and discrete optimization problems can be formulated in a high-level modeling language. Models are compiled into an intermediate representation that is understood by a wide range of solvers. MiniZinc itself provides several solvers, for instance GeoCode. The existing packages in R are not powerful enough to solve even mid-sized problems in combinatorial optimization

There are implementations of an Interface to MiniZinc in Python like MiniZinc Python and pymzn and JMiniZinc for Java but such an interface does not exist for R.

This package provides an implementation of a very simple and easy to use interface for R that will help R users to solve optimization problems that can't be solved with R currently.

It's important to understand R6 classes before getting into the details. If you are not comfortable with R6, please go through this [tutorial](https://adv-r.hadley.nz/r6.html).

It would be nice to go through this [manual](https://www.minizinc.org/tutorial/minizinc-tute.pdf) to understand more about MiniZinc. This is mainly for those who are interested in contributing to the package.

Please make sure to install MiniZinc on your operating system and also ensure that minizinc is accessible from command line by typing 'minizinc' on the command line without the single quotes. The installation instructions can be found at [instructions](https://www.minizinc.org/doc-2.4.3/en/installation.html)


# Variables

There are two types of variables in MiniZinc -- decision variables and parameters. 

The data types of variables can be single types i.e integers (int), floating point numbers (float), Booleans (bool) and strings (string) but strings are only used in output formatting so they won't be used as data types and collections i.e sets, enums and arrays (upto 5 dimensional arrays).

Parameter is used to specify a parameter in a given problem and they are assigned a fixed value.

Decision variables are the unknowns that Minizinc model is finding solutions for. We do not need to give them a value, but instead we give them a domain of possible values. Sometimes expressions involving other variables and paramters are also assigned to decision variables. Decision variables need to satisfy a set of constraints which form the core of the problem. 

Here are examples of how we can create parameters and decision variables.

```{r}
library(rminizinc)
par = variable$new(type = "array", kind = "parameter", value = array(data = c(1,2,3,4,5)))
dec = variable$new(type = "float", kind = "decision", domain = c(0, 1))
```

More information on variable is available in `?variable`. 

# Constraints

Constraints specify the Boolean expressions that decision variables must satisfy. Examples of such constraints are given below. 

```{r}
par = variable$new(type = "float", kind = "parameter", value = 0.8)
var1 = variable$new(type = "float", kind = "decision", domain = c(0, par$value))
var2 = variable$new(type = "float", kind = "decision", domain = c(0, par$value))

constr = constraint$new(operator = ">=", variables = c(var1, var2))
```

For now, this package can only support relational constraints that involve two variables at a time only. Once the development of the get_expression class is finshed, the package will support expressions involving multiple operators and variables.

# Objective

The constraint programming problem can be of three types, namely: Satisfaction , Minimization and Maximization.
Satisfaction problems produce all the solutions that satify the constraints whereas minimization and maximization problems produce the solution which minimizes and maximizes the given arithmetic expression.
An example of how to specify the objective is shown below:

```{r}
obj <- objective$new(type_of_problem = "satisfy")
```
Currently the minimization and maximization problems are not supported. They will be supported once the development of get_expression class is finished.

# Models

The components mentioned above can be combined to create a MiniZinc model. The demonstration of the same is given below:

Here is an example of map coloring problem of Australian states. 

```{r}
# parameter variable
p1 = variable$new(type = "int", value = 3, kind = "parameter")

# decision variables
v1 = variable$new(type = "int", kind = "decision", domain = c(1, p1$value), 
                  name = "wa")
v2 = variable$new(type = "int", kind = "decision", domain = c(1, p1$value), 
                  name = "nt")
v3 = variable$new(type = "int", kind = "decision", domain = c(1, p1$value), 
                  name = "sa")
v4 = variable$new(type = "int", kind = "decision", domain = c(1, p1$value),
                  name = "q")
v5 = variable$new(type = "int", kind = "decision", domain = c(1, p1$value),
                  name = "nsw")
v6 = variable$new(type = "int", kind = "decision", domain = c(1, p1$value),
                  name = "v")
v7 = variable$new(type = "int", kind = "decision", domain = c(1, p1$value),
                  name = "t")

vars = c(v1, v2, v3, v4, v5, v6, v7)

# constraints
c1 = constraint$new(operator = "!=", variables = c(v1, v2))
c2 = constraint$new(operator = "!=", variables = c(v1, v3))
c3 = constraint$new(operator = "!=", variables = c(v2, v3))
c4 = constraint$new(operator = "!=", variables = c(v2, v4))
c5 = constraint$new(operator = "!=", variables = c(v3, v4))
c6 = constraint$new(operator = "!=", variables = c(v3, v5))
c7 = constraint$new(operator = "!=", variables = c(v3, v6))
c8 = constraint$new(operator = "!=", variables = c(v4, v5))
c9 = constraint$new(operator = "!=", variables = c(v5, v6))

constr = c(c1, c2, c3, c4, c5, c6, c7, c8, c9)

objective_of_problem  = objective$new(type_of_problem = "satisfy")

# create the model
m = model$new(parameter = c(p1), decision = vars, constraints = constr, 
              objective = objective_of_problem)
```

Now, we have created the model and have set up MiniZinc on our system. The next step is to evaluate the results.
The information about result class and how to use it correctly can be found using `?results`

```{r}
solution <- results$new(model = m, result_type = "string")
# show the solution
print(solution$result)
```
Currently, the utility to get parsed results as R6 objects has not been provided. It will be provided later
when the parser to parse the MiniZinc solutions is developed.


```{r,echo=FALSE}
# remove the temporary model file 
file.remove(solution$mzn)
```

A Minizinc implementation of the same problem is given below:

```{minizinc}
% Colouring Australia using nc colours
int: nc = 3;

var 1..nc: wa;   var 1..nc: nt;  var 1..nc: sa;   var 1..nc: q;
var 1..nc: nsw;  var 1..nc: v;   var 1..nc: t;

constraint wa != nt;
constraint wa != sa;
constraint nt != sa;
constraint nt != q;
constraint sa != q;
constraint sa != nsw;
constraint sa != v;
constraint q != nsw;
constraint nsw != v;
solve satisfy;

```


Now, that the basic structure of the problem is clear, we can create functions for solving different constraint programming problems.






