---
title: "MiniZinc Interface for R"
author: Akshit Achara 
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{R functionalities to use MiniZinc}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---


## Introduction

MiniZinc is a free and open-source constraint modeling language. Constraint satisfaction and discrete optimization problems can be formulated in a high-level modeling language. Models are compiled into an intermediate representation that is understood by a wide range of solvers. MiniZinc itself provides several solvers, for instance GeCode. The existing packages in R are not powerful enough to solve even mid-sized problems in combinatorial optimization

There are implementations of an Interface to MiniZinc in Python like MiniZinc Python and pymzn and JMiniZinc for Java but such an interface does not exist for R.

This package provides an implementation of a very simple and easy to use interface for R that will help R users to solve optimization problems that can't be solved with R currently.

It's important to understand R6 classes before getting into the details. If you are not comfortable with R6, please go through this [tutorial](https://adv-r.hadley.nz/r6.html).

It would be nice to go through this [manual](https://www.minizinc.org/tutorial/minizinc-tute.pdf) to understand more about MiniZinc. This is mainly for those who are interested in contributing to the package.

Please make sure to install MiniZinc on your operating system and also ensure that minizinc is accessible from command line by typing 'minizinc' on the command line without the single quotes. The installation instructions can be found at [instructions](https://www.minizinc.org/doc-2.4.3/en/installation.html)


## Variables

There are two types of variables in MiniZinc -- decision variables and parameters. 

The data types of variables can be single types i.e integers (int), floating point numbers (float), Booleans (bool) and strings (string) and collections i.e sets, enums and arrays (upto 5 dimensional arrays).

Parameter is used to specify a parameter in a given problem and they are assigned a fixed value or expression.

Decision variables are the unknowns that Minizinc model is finding solutions for. We do not need to give them a value, but instead we give them a domain of possible values. Sometimes expressions involving other variables and parameters are also assigned to decision variables. Decision variables need to satisfy a set of constraints which form the core of the problem. 

Here are examples of how we can create parameters and decision variables.

```{r}
library(rminizinc)

# create the variable and parameter declarations

par1_name = Id$new(ID = "n")
par_dt = Int$new(value = 4)
par_tp = Type$new(base_type = "INT", kind = "parameter")
par1 = VarDecl$new(expression = par_dt, type = par_tp, id = par1_name)
# create the Item 1
item1 = VarDeclItem$new(decl = par1)

par2_name = Id$new(ID = "OBJ")
sv = SetVal$new(val = c(l = 1, u=3))
par2_dt = Set$new(setVal = sv)
par2_tp = Type$new(base_type = "INT", kind = "parameter", dim = 1, set_type = TRUE)
par2 = VarDecl$new(type = par2_tp, expression = par2_dt, id = par2_name)
# create the item 2
item2 = VarDeclItem$new(decl = par2)

par3_name = Id$new(ID = "capacity")
par3_tp = Type$new(base_type = "INT", kind = "parameter")
par3 = VarDecl$new(type = par3_tp, id = par3_name)
# create the item 3
item3 = VarDeclItem$new(decl = par3)

par4_name = Id$new(ID = "profit")
par4_tp = Type$new(base_type = "INT", type_inst = TypeInst$new(Id$new(ID = "OBJ")), kind = "parameter", dim = 1)
par4 = VarDecl$new(type = par4_tp, id = par4_name)
# create the item 4
item4 = VarDeclItem$new(decl = par4)

par5_name = Id$new(ID = "size")
par5_tp = Type$new(base_type = "INT", type_inst = TypeInst$new(Id$new(ID = "OBJ")), kind = "parameter", dim = 1)
par5 = VarDecl$new(type = par5_tp, id = par5_name)
# create the item 5
item5 = VarDeclItem$new(decl = par5)

par6_name = Id$new(ID = "x")
par6_tp = Type$new(base_type = "INT", kind = "decision", type_inst = TypeInst$new(Id$new(ID = "OBJ")), dim = 1)
par6 = VarDecl$new(type = par6_tp, id = par6_name)
#create the item 6
item6 = VarDeclItem$new(decl = par6)
```

# Constraints

Create constraints

```{r}
gen_forall = list(Generator$new(IN = Id$new(ID = "OBJ")))
bop1 = Binop$new(lhs_expression = ArrayAccess$new(id = Id$new("x"), index = Id$new("i")), binop = ">=", 
                                        rhs_expression =    Int$new(value = 0))
Comp1 = Comprehension$new(generators = gen_forall, expression = bop1)
cl1 = Call$new(fn_id = Id$new("forall"),lExp = list(Comp1))
# item7 
item7 = ConstraintItem$new(expression = cl1)
item7$c_str()

gen_sum = list(Generator$new(IN = Id$new(ID = "OBJ")))
bop2 = Binop$new(lhs_expression = ArrayAccess$new(id = Id$new("size"), index = Id$new("i")), binop = "*", 
                                      rhs_expression = ArrayAccess$new(id = Id$new("x") ,index = Id$new("i")))
Comp2 = Comprehension$new(generators = gen_sum, expression = bop2)
cl2 = Call$new(fn_id = Id$new(ID = "sum"),lExp = list(Comp2))
bop3 = Binop$new(lhs_expression = cl2, binop = "<=", rhs_expression = Id$new(ID = "capacity"))
# item8
item8 = ConstraintItem$new(expression = bop3)
```


# Solve Type

The constraint programming problem can be of three types, namely: Satisfaction , Minimization and Maximization.
Satisfaction problems produce all the solutions that satisfy the constraints whereas minimization and maximization problems produce the solution which minimizes and maximizes the given arithmetic expression.
An example is shown below:

```{r}

gen_sum = list(Generator$new(IN = Id$new(ID = "OBJ")))

bop4 = Binop$new(lhs_expression = ArrayAccess$new(id = Id$new("profit"),index = Id$new("i")), 
                      binop = "*", rhs_expression = ArrayAccess$new(id = Id$new("x"), index = Id$new("i")))

Comp3 = Comprehension$new(generators = gen_sum, expression = bop4)

cl3 = Call$new(fn_id = Id$new("sum"),lExp = list(Comp3))
# item9
item9 = SolveItem$new(solve_type = "maximize", expression = cl3)
```
#' Create the model

Combine all the items to create a MiniZinc model
```{r}
items  = c(item1, item2, item3, item4, item5, item6, item7, item8, item9)
mod = Model$new(items = items)
modString = mod$mzn_string()
```

# Solve the model

Solve the model using the Rcpp functions that are using the MiniZinc.

```{r}
dzn_path = paste0(dirname(getwd()), "/mzn_examples/knapsack/knapsack_0.dzn")
sol = rminizinc:::mzn_eval(modelString = modString, solver = "org.gecode.gecode",
                      libpath = "/snap/minizinc/current/share/minizinc", dznpath = dzn_path)
```


A Minizinc implementation of the same problem is given below:

```{minizinc}

int: n; % number of objects
set of int: OBJ = 1..n;
int: capacity;
array[OBJ] of int: profit;
array[OBJ] of int: size;

array[OBJ] of var int: x; % how many of each object

constraint forall(i in OBJ)(x[i] >= 0);
constraint sum(i in OBJ)(size[i] * x[i]) <= capacity;
solve maximize sum(i in OBJ)(profit[i] * x[i]);

```

Now, that the basic structure of the problem is clear, we can create functions for solving different constraint programming problems.

The workflow of the approach used above is given below:
```{r Workflow 1, echo=FALSE, out.width = '100%'}
knitr::include_graphics(paste0(getwd(),"/workflows/write_model.png"))
```

This approach is helpful for R users who have little understanding of MiniZinc.

The next approach is to use the MiniZinc C++ API. This involves giving the MiniZinc model to the Rcpp function, evaluate the results and return them back to R. The workflow can be seen below:
```{r Workflow 2, echo=FALSE, out.width = '100%'}
knitr::include_graphics(paste0(getwd(),"/workflows/API.png"))
```
A parser function `mzn_parse` has also been implemented which can be used to detect possible syntax errors (and to modify the components of the model -- to be done later) before the MiniZinc model is evaluated. This function can either take the path of a model file path or it can take a string model and returns a list with five elements namely: `modelString` which is the string representation of the model and `Parameters` which are the parameter names, `decisionVariables` which are the decision variables of 
a model, `Constraints` which are the constraints of a model, `SolveType` which contains the information about the solve type of the problem and ode.

The function `set_params` can be used to set the missing parameters of the model. Any number of missing parameters can be set. The missing parameters can be obtained using `getMissingPars()`. 


```{r}
# mzn file path
mzn_path = paste0(dirname(getwd()), "/mzn_examples/knapsack/knapsack_0.mzn")

# parse the model
parseObj=rminizinc:::mzn_parse(mznpath = mzn_path)

# get the modelString
modString = parseObj$modelString

# dzn file path
dzn_path = paste0(dirname(getwd()), "/mzn_examples/knapsack/knapsack_0.dzn")

# R List object containing the solutions
solObj = rminizinc:::mzn_eval(modelString = modString, solver = "org.gecode.gecode",
                     libpath = "/snap/minizinc/current/share/minizinc", dznpath = dzn_path)
# get all the solutions
print(solObj$Solutions)
```
The data can also be provided as a list of values of parameters where the names of the list are the missing parameter names returned by `parse_mzn()`. For now, only integer, floats, bools, 1 dimensional integer and string arrays, 2 dimensional integer arrays and integer, float and bool sets are supported. Alternatively, if the user wishes to provide a data file, it can be provided to the function `mzn_eval()`.

```{r}
# file path
mzn_path = paste0(dirname(getwd()), "/mzn_examples/knapsack/knapsack_0.mzn")

# get missing parameter values
missingVals=rminizinc:::getMissingPars( mznpath = mzn_path)
print(missingVals)

# list of the data
pVals = list(3,9,c(15,10,7),c(4,3,2))
names(pVals) = missingVals

# set the missing parameters
modString = rminizinc:::set_params(modData = pVals,mznpath = mzn_path, modify_mzn = FALSE)

# R List object containing the solutions
solObj = rminizinc:::mzn_eval(modelString = modString, solver = "org.gecode.gecode",
                     libpath = "/snap/minizinc/current/share/minizinc")
# get all the solutions
print(solObj$Solutions)

```

Some examples of how to use these functions to solve optimization problems can be found in `mzn_examples` which are taken from [minizinc-examples](https://github.com/MiniZinc/minizinc-examples).

NOTE: Please don't include output formatting in the mzn files or the solutions might not be parsed properly.

The next step is to allow the users to add variables, constraints,etc in a MiniZinc model.


